import { GoogleGenAI, Modality, GenerateContentParameters, Type } from "@google/genai";
import type { Message } from '../types';

if (!process.env.API_KEY) {
  throw new Error("API_KEY environment variable not set");
}

const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });

export const callGeminiModel = async (
  contents: GenerateContentParameters['contents'],
  systemInstruction: string,
  tools?: any[],
  isLiteMode: boolean = false
) => {
  const config: any = {
      systemInstruction: systemInstruction,
      tools: tools,
      temperature: 0.7,
  };

  if (isLiteMode) {
      config.thinkingConfig = { thinkingBudget: 0 };
  }

  const response = await ai.models.generateContent({
    model: 'gemini-2.5-flash',
    contents,
    config,
  });
  return response;
};

export const performWebSearch = async (query: string): Promise<{ summary: string; citations: { uri: string; title: string }[] }> => {
  try {
    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash',
      contents: query,
      config: {
        tools: [{ googleSearch: {} }],
      },
    });

    const summary = response.text;
    const groundingChunks = response.candidates?.[0]?.groundingMetadata?.groundingChunks;
    const citations = groundingChunks
      ?.map((c: any) => c.web)
      .filter(Boolean) || [];
    
    const uniqueCitations = Array.from(new Map(citations.map((item: any) => [item.uri, item])).values()) as { uri: string; title: string; }[];

    return { summary, citations: uniqueCitations };
  } catch (error) {
    console.error("Web search failed:", error);
    return { summary: "Sorry, I couldn't perform the web search.", citations: [] };
  }
};

export const generateSummary = async (messages: Message[]): Promise<string> => {
  const historyText = messages
    .filter(m => m.type !== 'summary')
    .map(m => `${m.role === 'user' ? 'User' : 'AI'}: ${m.text}`)
    .join('\n');

  const prompt = `Provide a concise, neutral summary of the key points from the following conversation:\n\n---\n${historyText}\n---`;

  const response = await ai.models.generateContent({
    model: 'gemini-2.5-flash',
    contents: prompt,
    config: {
      systemInstruction: "You are an expert at summarizing conversations. Your summary should be brief, objective, and highlight the main topics and conclusions.",
      temperature: 0.2,
    }
  });

  return response.text;
};


export const generateImage = async (prompt: string) => {
  const response = await ai.models.generateImages({
    model: 'imagen-4.0-generate-001',
    prompt: prompt,
    config: {
      numberOfImages: 1,
      outputMimeType: 'image/png',
      aspectRatio: '1:1',
    },
  });
  
  const base64ImageBytes: string = response.generatedImages[0].image.imageBytes;
  return `data:image/png;base64,${base64ImageBytes}`;
};

export const editImage = async (base64ImageData: string, mimeType: string, prompt: string): Promise<string> => {
    const response = await ai.models.generateContent({
        model: 'gemini-2.5-flash-image-preview',
        contents: {
            parts: [
                {
                    inlineData: {
                        data: base64ImageData,
                        mimeType: mimeType,
                    },
                },
                {
                    text: prompt,
                },
            ],
        },
        config: {
            responseModalities: [Modality.IMAGE, Modality.TEXT],
        },
    });

    for (const part of response.candidates[0].content.parts) {
        if (part.inlineData) {
            const base64ImageBytes: string = part.inlineData.data;
            return `data:${part.inlineData.mimeType};base64,${base64ImageBytes}`;
        }
    }

    throw new Error("No image was generated by the edit operation.");
};

export const generateTitleForChat = async (messages: Message[]): Promise<string> => {
  const historyText = messages
    .slice(0, 2)
    .map(m => `${m.role === 'user' ? 'User' : 'AI'}: ${m.text}`)
    .join('\n');

  const prompt = `Based on this conversation, create a very short, concise title (4 words max). Do not use quotes or any introductory text. Just the title.\n\nConversation:\n${historyText}\n\nTitle:`;

  try {
    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash',
      contents: prompt,
      config: {
        systemInstruction: "You are an expert at creating concise, descriptive titles for conversations.",
        temperature: 0.3,
        stopSequences: ['\n'],
      }
    });
    
    let title = response.text.trim().replace(/["']/g, '');
    if (title.length > 50) {
        title = title.substring(0, 47) + '...';
    }
    return title || "Untitled Chat";

  } catch (error) {
    console.error("Title generation failed:", error);
    return "Untitled Chat";
  }
};

export const extractMemoriesFromChat = async (lastUserMessage: string): Promise<{key: string; value: string}[]> => {
  if (!lastUserMessage) return [];

  const prompt = `Analyze the following user message to extract any personal information, preferences, or facts about the user. Only extract information explicitly stated by the user. Do not infer. If no personal information is found, return an empty array.

User Message: "${lastUserMessage}"`;

  try {
    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash',
      contents: prompt,
      config: {
        systemInstruction: "You are an information extraction AI. Your task is to identify personal details about a user from their message and return them as a structured JSON array of key-value pairs. The 'key' should be a concise, lowercase label (e.g., 'name', 'location', 'hobby'). The 'value' is the information provided by the user. Do not add any information that isn't directly from the user's message. Do not include your own thoughts or explanations.",
        responseMimeType: "application/json",
        responseSchema: {
          type: Type.ARRAY,
          items: {
            type: Type.OBJECT,
            properties: {
              key: {
                type: Type.STRING,
                description: 'A concise, lowercase label for the piece of information (e.g., name, occupation, pet_name).',
              },
              value: {
                type: Type.STRING,
                description: 'The specific piece of information extracted from the message.',
              },
            },
            required: ['key', 'value']
          },
        },
      },
    });

    const memories = JSON.parse(response.text);
    return Array.isArray(memories) ? memories : [];
  } catch (error) {
    console.error("Memory extraction failed:", error);
    return []; // Return empty array on failure
  }
};

export const generateVideo = async (prompt: string): Promise<Blob> => {
  let operation = await ai.models.generateVideos({
    model: 'veo-2.0-generate-001',
    prompt: prompt,
    config: {
      numberOfVideos: 1,
    },
  });

  while (!operation.done) {
    await new Promise(resolve => setTimeout(resolve, 10000));
    operation = await ai.operations.getVideosOperation({ operation: operation });
  }

  const downloadLink = operation.response?.generatedVideos?.[0]?.video?.uri;
  if (!downloadLink) {
    throw new Error('Video generation succeeded, but no download link was provided.');
  }

  const response = await fetch(`${downloadLink}&key=${process.env.API_KEY}`);
  if (!response.ok) {
    throw new Error(`Failed to download video: ${response.statusText}`);
  }
  return response.blob();
};

export const styleTitleCard = async (text: string): Promise<any> => {
  const prompt = `Suggest creative styling for a video title card with the text "${text}". Provide CSS properties for font size (in vw), color, background color, and font family (use a common, web-safe or Google Font).`;
  
  const response = await ai.models.generateContent({
    model: 'gemini-2.5-flash',
    contents: prompt,
    config: {
      systemInstruction: "You are a graphic designer AI. Your task is to suggest styling for a title card and return it as a structured JSON object.",
      responseMimeType: "application/json",
      responseSchema: {
        type: Type.OBJECT,
        properties: {
          fontFamily: { type: Type.STRING, description: "A web-safe or Google Font family name." },
          fontSize: { type: Type.NUMBER, description: "Font size in vw units for responsiveness." },
          color: { type: Type.STRING, description: "A hex code for the text color." },
          backgroundColor: { type: Type.STRING, description: "A hex or rgba code for the background color." },
        },
        required: ['fontFamily', 'fontSize', 'color', 'backgroundColor'],
      },
    },
  });

  return JSON.parse(response.text);
};